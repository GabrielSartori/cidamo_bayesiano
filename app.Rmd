---
title: "Inferência Bayesiana"
output:
  xaringan::moon_reader:
    seal: false 
    self_contained: true
    nature: 
        ratio: '16:9'
        slideNumberFormat: "%current%"     
---

# Exemplo Didático 

+ Votos em Eleição


# Conceitos Fundamentais

+ Amostra, Parâmetro, Incerteza


# Distribuição de Probabilidade

+ Variável Aleatórias
+ Espaço Amostral
+ Familias de Distribuição

# Homo Bayesianos 

# Panorama Aprendizado de Máquina

+ Treino..., Teste....
+ Interpretabilidade


# Panorama Frequentista

+ Estatística do Teste,
+ P-valor....

# Panorama Bayesiano

+ Prioris
+ Posteori
+ panorama histórico

# Vantagens e Desvantagens


# Teorema Bayesiano

+ Regra de Bayes

# Métodos de Estimação

+ Analítico
    + priori conjugadas
+ Simulação
+ Aproximados
    + amostrador de gibbs
    + MCMC
---
class: middle, center
background-color: #E0F2F1

# Exemplo Teste A/B

---
class: middle, center
background-image: url(https://miro.medium.com/max/1400/0*IbFC5ucifDGZ1Ej1.)
background-size: contain

---
# Exemplo Teste A/B Bayesiano

+ Muito Natural calcular a diferença de Proporção

+ 25% é Maior que 5%?

--
+ Estatística do Teste

    + t-teste, z-teste

    + comparar p-valor

---
# Contexto Bayesiano

+ **Assumimos uma distribuição Priori**: 

$$  \frac{\Gamma(\alpha +\beta)}{\Gamma(\alpha)\Gamma(\beta)}x^{\alpha - 1}(1 - x)^{\beta - 1} $$

+ Parâmetros: 
    + $\alpha$ = sucesso
    + $\beta$ = fracasso

--
+ **Distribuição da verossimilhança**: 

$$    f(x) = {{N}\choose{x}} \cdot \theta^{x}(1-\theta)^{N-x} $$

+ Parâmetros: 
    + n = Total de Anúncios
    + x = Total de pessoas que clicaram

---
# Posteriori Bayesiana

$$ P(\theta|\textbf{x}) = P(\theta ) \frac{P(\textbf{x} |\theta)}{P(\textbf{x})} $$

$$ PDF(Beta) * PDF(Binomial) = PDF(BETA) $$

+ Parâmetros: 
    + $\alpha$ = priori_sucesso + x
    + $\beta$ = priori_fracasso + (n-x) 

---
class: middle, center
background-image: url(https://miro.medium.com/max/475/0*EvwsWFC_P7M6RnFP)
background-size: contain

---
class: middle, center
background-color: #E0F2F1
# Exemplo Simulado

---
# Aplicando Teorema de Bayes

```{python, echo = FALSE}
from scipy.stats import beta, gamma
import matplotlib.pyplot as plt
import seaborn as sns
import pandas as pd
import numpy as np
```

```{python}
#Priori
priori_alpha = 1
priori_beta = 1

# Conversão
sample_a = 500
conversion_a = 125

sample_b = 500
conversion_b = 25

# Posteriori
posterior_a = beta(
      priori_alpha + conversion_a
    , priori_beta + sample_a - conversion_a
    )

posterior_b = beta(
      priori_alpha + conversion_b
    , priori_beta + sample_b - conversion_b
    )
```

---
# Comparando resultados

```{python}
simulate_a = posterior_a.rvs(10000)
simulate_b = posterior_b.rvs(10000)
```

```{python, eval = FALSE, echo = FALSE}
sns.histplot(simulate_a, color = '#fee6ce')
sns.histplot(simulate_b, color = '#d0d1e6')
sns.despine()
plt.legend(title = 'Campanha', loc='upper left', labels=['Simulated A', 'Simulated B'])
plt.ylabel("")
plt.show()
fig.savefig('img/figure_sns.png', bbox_inches='tight')
```


<img src="img/fig_sns.png" alt="drawing" width="950"/>

---
# Métricas de Incerteza


```{python, echo = FALSE}
df = pd.DataFrame()

df['sim_A'] = simulate_a
df['sim_B'] = simulate_b

df.head()
```
--
+ Better
+ Loss
+ Uplift

---
# Better

+ a probabilidade da campanha do tratamento ser melhor que a campanha do controle

```{python}
better_trat = np.sum(simulate_b > simulate_a)
pct_better_trat = (better_trat/10000) * 100
pct_better_trat
```

---
# Loss

+ é a perda esperada se escolhermos a campanha do tratamento como melhor e na verdade ela for pior

```{python}
loss_trat = np.mean((simulate_b < simulate_a) * (simulate_b - simulate_a)/simulate_a)
loss_trat * 100
```

---
# UPLIFT 
+ é a melhora esperada se escolhermos a campanha tratamento como vencedora e ela realmente for melhor (uplift)

```{python}
uplift_trat = np.mean((simulate_b - simulate_a)/simulate_a) 
uplift_trat * 100
```

---
# Exemplo Regressão Linear

+ Exemplo R
+ Exemplo python


# Exemplo Prophet

\begin{equation}
y(t)=g(t)+s(t)+h(t)+\epsilon_{\ell}
\end{equation}

## Aonde o Prophet Brilha?

* Observações de hora em hora, diárias ou semanais com pelo menos alguns meses (de preferência um ano) de história

* Fortes sazonalidades múltiplas de “escala humana”: dia da semana e época do ano 

* Feriados importantes que ocorrem em intervalos irregulares que são conhecidos com antecedência

* Um número razoável de observações ausentes ou grandes outliers

* mudança nas tendências históricas, por exemplo, devido a lançamentos de produtos ou mudanças de registros

* Tendências que são curvas de crescimento não lineares, onde uma tendência atinge um limite natural ou satura depois de determinado tempo.

## Como o Prophet Funciona?

* Uma tendência de curva de crescimento linear ou logístico por partes. O Profeta detecta automaticamente as mudanças nas tendências, selecionando os pontos de mudança dos dados.

* Um componente sazonal anual modelado usando uma série de Fourier.

* Um componente sazonal semanal usando variáveis ​​dummy

* Uma lista fornecida pelo usuário de feriados importantes.


### O Modelo

Descreve como os valores de $y$ variam de acordo com as coisas de que dependem (features/covariáveis).

(linha 136 do https://github.com/facebook/prophet/blob/master/python/stan/unix/prophet.stan)
```{r, eval= FALSE}
y ~ normal(
  trend
  .* (1 + X * (beta .* s_m))
  + X * (beta .* s_a),
  sigma_obs
);
```

```{r, eval= FALSE}
y ~ normal(
  tendência
  .* variáveis_multiplicativas
  + variáveis_aditivas,
  variância_observado
);
```

### Os parâmetros

```{r, eval = FALSE}
parameters {
  real k;                   // taxa base de crescimento da tendência
  real m;                   // offset da tendência (intercepto)
  vector[S] delta;          // taxa de ajuste da tendência
  real<lower=0> sigma_obs;  // ruido das observações
  vector[K] beta;           // coeficientes da regressão
}
```

k e m são parâmetros para a tendência inicial e eles definem o que a linha de tendência faz até o primeiro ponto de mudança.

delta é um vetor de valores, cada um dos quais é quanto (e em que direção) a tendência muda em cada ponto de mudança. 
Por exemplo, se k é 0,5 e delta[1] é -0,3, então, após o primeiro ponto de mudança, a inclinação da tendência é 0,5-0,3 = 0,2.

Por padrão, o Prophet adiciona 10 termos de Fourier para sazonalidade anual e 10 para sazonalidade semanal à matriz de regressão. 
Estes são gerados em R / python antes que os dados sejam enviados para Stan.

### As Prioris

```{r, eval= FALSE}
k ~ normal(0, 5);
m ~ normal(0, 5);
delta ~ double_exponential(0, tau);
sigma_obs ~ normal(0, 0.5);
beta ~ normal(0, sigmas);

```

normal (0,5) é uma distribuição normal centrada em zero com variância cinco. 

Os valores nos dados são escalonados antes de serem enviados para Stan, de forma que tudo esteja entre 0 e 1. 

Isso significa que essa priori é relativamente “não informativa”, 
ele cobre uma ampla gama de valores razoáveis ​​e não estamos restringindo muito o que os valores podem ser. 

Isso é como dizer: "Não sei qual será o valor, mas tenho certeza de que não será muito grande nem muito pequeno".

k e m definem a tendência no início dos dados de treinamento; 
portanto, estamos dizendo que não sabemos realmente o que serão, 
mas que provavelmente não são extremos.

A priori para delta é muito diferente; a distribuição double_exponential. 
Isso significa que esperamos que os valores de delta sejam zero (ou muito próximos disso). 
Delta descreve o quanto a tendência muda em um ponto de mudança; usando este anterior, estamos dizendo que a tendência provavelmente não mudará; portanto, os dados devem conter fortes evidências de uma mudança de tendência para que haja uma mudança de fato no resultado final.

sigmas por padrão é 10, portanto, esta é uma priori ainda mais vaga (não informativa) do que na tendência.

# Glossário

+ Léo Bastos Estimação Óbitos Covid

<!-- Objetivos Indiretos 


-->

<!-- Links 
https://www.bayesrulesbook.com/chapter-1.html#a-quick-history-lesson
https://docs.pymc.io/nb_examples/index.html 
https://www.youtube.com/watch?v=LSOl_7qAFD0

http://www.sumsar.net/images/posts/2018-12-13-visualizing-the-beta-binomial/prop_model_animation.gif
-->

<!-- Atividades -->

<!-- LEG COnceitual: JUNTOS --> 

<!-- Dennis 



--> 


<!-- Gabriel 

+ Temas css 
+ Didático Teste A/B
    + Beta Binomial
    https://docs.pymc.io/pymc-examples/examples/case_studies/BEST.html

+ tema css
--> 
